import messenger from './messenger';
import { error, getPlayerPath, cardsInOrder } from 'stateUtils';

const playCard = (state, player, card) => {
    let playerPath = getPlayerPath(state, player),
        cardType = card.type,
        action = 'playCard';
    
    if (state.get('roundStage') != 'cardsCollection') {
        return error(state, {
            action,
            player,
            card,
            error: 'can\'t play card in phase other than cards collection'
        });
    }

    if (state.get('cardsInPlay').findIndex(x => x.player == player) != -1) {
        return error(state, {
            action,
            error: 'specified player already had played card'
        });
    }

    if (!state.getIn([...playerPath, 'cards', 'hand']).has(cardType)) {
        return error(state, {
            action,
            error: 'can\'t play specified card: player have no such card in hand'
        });
    }

    if (cardType == 'ARCHITECT' && state.getIn([...playerPath, 'cards', 'discardPile']).size == 0) {
        return error(state, {
            action,
            error: 'architect cannot be played with full hand'
        });
    }

    state = state
        .updateIn(
            [...playerPath, 'cards', 'hand'],
            item => item.remove(cardType)
        )
        .updateIn(
            [...playerPath, 'cards', 'discardPile'],
            item => item.add(cardType)
        ).
        update('cardsInPlay', x => x.push({
            player: player,
            card: cardType
        }));
    
    return state.set('current');  
};

const processCards = state => {
    switch(state.get('roundStage')) {
    case 'MESSENGER':
        for({card, player} in cardsInOrder({
            cards: state.get('cardsInPlay'),
            cardType: 'MESSENGER',
            currentPlayer: state.get('currentPlayer'),
            players: state.get('players').map(x => x.get('color'))
        })) {
            state = messenger(state, player);
        }
            
        break;
    }
    
            
    return state;        
};

export {
    playCard,
    processCards
}
